# -*- coding: utf-8 -*-
"""계정별원장(현금)_대시보드_004.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hyhZl6iSi496GhXnjLVxg-4b-gzac1Ed
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# import pandas as pd
# import plotly.express as px
# import io
# import numpy as np
# from datetime import date
# from dateutil.relativedelta import relativedelta
# import calendar
# 
# # 페이지 구성을 와이드 레이아웃으로 설정
# st.set_page_config(layout="wide")
# 
# st.title('현금흐름 대시보드')
# 
# # ---
# # Sidebar: 엑셀 파일 업로드 및 처리
# # ---
# st.sidebar.header('엑셀 파일 처리')
# 
# # 엑셀 파일 업로드 기능 추가
# uploaded_file = st.sidebar.file_uploader("엑셀 파일을 업로드하세요", type=['xls', 'xlsx'])
# 
# # 불필요한 컬럼 목록
# columns_to_drop = [
#     'No', '계정코드', '계정명', '승인번호', '비용센터코드', '비용센터',
#     '프로젝트', '프로젝트명', '증빙', '예산단위', '예산계정', '회계단위', '거래처코드','거래처',
#     '작성부서', '작성자', '작성일', '순번', '메뉴', '전표유형코드', '관리항목코드1', '관리항목1',
#     '계정유형', '전표유형명', '관리항목코드4', '관리항목4', '관리항목코드5', '관리항목5',
#     '관리항목코드7', '관리항목7', '관리항목코드8', '관리항목8'
# ]
# 
# # 관리항목코드와 현금흐름 항목 매핑 딕셔너리
# cash_flow_mapping = {
#     1110: '제품매출', 1120: '상품매출', 1130: '용역매출', 1990: '기타수입',
#     2110: '이자수입', 2120: '영업외수입', 2140: '대여금 회수',
#     3110: '자산매각', 3120: '차입금/사채조달', 5110: '상품구입',
#     5120: '원부자재구매', 5220: '인건비', 5310: '일반경비',
#     5340: '퇴직연금 불입', 6110: '차입금 이자지급', 6120: '배당금지급',
#     6130: '세금납부', 6140: '대여금지급', 6210: '법인세 납부',
#     7110: '자산매입', 7120: '차입금/사채상환', 7130: '금융상품투자(적립)',
#     9010: '자금대체', 9020: 'FX거래'
# }
# 
# if uploaded_file:
#     try:
#         # 업로드된 엑셀 파일을 DataFrame으로 읽기
#         df = pd.read_excel(uploaded_file, engine='openpyxl')
# 
#         # '순번' 컬럼을 남겨두고 불필요한 컬럼 삭제
#         columns_to_drop_without_순번 = [col for col in columns_to_drop if col != '순번']
#         df_cleaned = df.drop(columns=columns_to_drop_without_순번, errors='ignore')
# 
#         # '관리항목코드' 컬럼들을 숫자형으로 강제 변환
#         # errors='coerce'를 사용하여 변환할 수 없는 값은 NaN으로 만듦
#         for col in ['관리항목코드2', '관리항목코드3', '관리항목코드6']:
#             if col in df_cleaned.columns:
#                 df_cleaned[col] = pd.to_numeric(df_cleaned[col], errors='coerce').astype('Int64')
# 
#         # '회계일' 컬럼을 datetime 형식으로 변환
#         if '회계일' in df_cleaned.columns:
#             df_cleaned['회계일'] = pd.to_datetime(df_cleaned['회계일'])
# 
#         # '현금흐름 항목' (T열) 추가
#         def get_cash_flow_item(row):
#             for col in ['관리항목코드2', '관리항목코드3', '관리항목코드6']:
#                 # 값이 유효한 정수형인지 확인
#                 if pd.notna(row.get(col)) and isinstance(row.get(col), (int, np.integer)):
#                     code = row[col]
#                     if code in cash_flow_mapping:
#                         return cash_flow_mapping[code]
#             return None # 해당되는 코드가 없을 경우 None 반환
# 
#         # '현금흐름 항목' 컬럼 생성 및 값 채우기
#         df_cleaned['현금흐름 항목'] = df_cleaned.apply(get_cash_flow_item, axis=1)
# 
#         # '구분' 컬럼 추가 (이미지 기반)
#         # '현금흐름 항목'을 기준으로 '수입', '지출', '대체'로 구분합니다.
#         classification_mapping = {
#             '제품매출': '수입', '상품매출': '수입', '용역매출': '수입', '기타수입': '수입',
#             '이자수입': '수입', '영업외수입': '수입', '대여금 회수': '수입', '자산매각': '수입',
#             '차입금/사채조달': '수입', '상품구입': '지출', '원부자재구매': '지출', '인건비': '지출',
#             '일반경비': '지출', '퇴직연금 불입': '지출', '차입금 이자지급': '지출', '배당금지급': '지출',
#             '세금납부': '지출', '대여금지급': '지출', '법인세 납부': '지출', '자산매입': '지출',
#             '차입금/사채상환': '지출', '금융상품투자(적립)': '지출', '자금대체': '대체', 'FX거래': '대체'
#         }
#         df_cleaned['구분'] = df_cleaned['현금흐름 항목'].map(classification_mapping)
# 
#         st.sidebar.success("파일이 성공적으로 처리되었습니다.")
# 
#         # --- 현금흐름 대시보드 레이아웃 ---
# 
#         # 1. 기초일자와 기말일자 계산 및 사이드바에 표시
#         if not df_cleaned.empty and '회계일' in df_cleaned.columns:
#             start_date = df_cleaned['회계일'].min().strftime('%Y년 %m월 %d일')
#             end_date = df_cleaned['회계일'].max().strftime('%Y년 %m월 %d일')
#             st.sidebar.markdown(f"**기초일자**: {start_date}")
#             st.sidebar.markdown(f"**기말일자**: {end_date}")
# 
#         # 2. 3단 컬럼 레이아웃 생성
#         # 요청에 따라 컬럼 너비를 20:40:40 비율로 조정합니다.
#         col1, col2, col3 = st.columns([20, 40, 40])
# 
#         # 3. 컬럼 1: 기초 현금잔액 및 기말 현금잔액
#         with col1:
#             st.subheader("현금잔액 현황")
#             if not df_cleaned.empty and '잔액' in df_cleaned.columns:
#                 # 현금잔액을 백만원 단위로 변환하여 소수점 없이 표시
#                 start_balance_mil = df_cleaned['잔액'].iloc[0] / 1_000_000
#                 end_balance_mil = df_cleaned['잔액'].iloc[-1] / 1_000_000
#                 st.metric(label=f"기초 현금잔액 ({start_date})", value=f"{start_balance_mil:,.0f} 백만원")
#                 st.metric(label=f"기말 현금잔액 ({end_date})", value=f"{end_balance_mil:,.0f} 백만원")
#             else:
#                 st.info("데이터가 충분하지 않습니다.")
# 
#         # 4. 컬럼 2: 월별 현금 잔액 그래프 및 지출 추이 그래프
#         with col2:
#             st.subheader("월별 현금 잔액 추이")
#             if not df_cleaned.empty and '회계일' in df_cleaned.columns and '잔액' in df_cleaned.columns and '전표번호' in df_cleaned.columns and '순번' in df_cleaned.columns:
#                 # '전표번호'에서 'FI' 뒤의 숫자 추출 및 숫자형으로 변환
#                 df_cleaned['전표번호_num'] = df_cleaned['전표번호'].str.extract(r'FI(\d+)').astype(float)
# 
#                 # '회계일', '전표번호_num', '순번'을 기준으로 정렬
#                 # '회계일' 오름차순, '전표번호_num' 오름차순, '순번' 오름차순
#                 df_sorted = df_cleaned.sort_values(
#                     by=['회계일', '전표번호_num', '순번'],
#                     ascending=[True, True, True]
#                 ).copy()
# 
#                 # 각 월의 마지막 거래만 추출
#                 monthly_last_balance = df_sorted.groupby(
#                     df_sorted['회계일'].dt.strftime('%Y-%m')
#                 ).tail(1).copy()
# 
#                 # '회계일'을 'YYYY-MM' 형식의 문자열로 변환하여 새로운 컬럼 '월'을 생성합니다.
#                 monthly_last_balance['월'] = monthly_last_balance['회계일'].dt.strftime('%Y-%m')
# 
#                 # 월의 마지막 날짜를 포함하는 새로운 컬럼을 만들고,
#                 # 이를 툴팁에 명시적으로 사용하도록 설정합니다.
#                 monthly_last_balance['툴팁_날짜'] = monthly_last_balance['회계일'].dt.strftime('%Y년 %m월 %d일')
# 
#                 # 꺾은선 그래프 생성 (x축에 '월' 컬럼 사용)
#                 fig_balance = px.line(
#                     monthly_last_balance,
#                     x='월',
#                     y='잔액',
#                     markers=True,
#                     title='월별 현금 잔액',
#                     # 툴팁에 사용할 데이터를 custom_data로 전달합니다.
#                     custom_data=['툴팁_날짜', '잔액']
#                 )
# 
#                 # 툴팁 및 X축 라벨 설정
#                 fig_balance.update_layout(
#                     xaxis_title=None,
#                     yaxis_title="잔액",
#                     hovermode="x unified",
#                     hoverlabel=dict(
#                         bgcolor="white",
#                         font_size=12,
#                         font_family="Arial"
#                     ),
#                     xaxis=dict(tickangle=0)
#                 )
# 
#                 # 툴팁 템플릿을 사용자 정의하여 '툴팁_날짜'와 '잔액'을 표시합니다.
#                 fig_balance.update_traces(
#                     hovertemplate='<b>%{customdata[0]}</b><br>잔액: %{customdata[1]:,.0f} 원<extra></extra>'
#                 )
# 
#                 st.plotly_chart(fig_balance, use_container_width=True)
# 
#                 # --- 월별 지출 추이 그래프 추가 (항목별로 여러 개) ---
#                 st.markdown("### 월별 지출 추이 (항목별)")
# 
#                 # '지출' 데이터만 필터링하고 '현금흐름 항목'이 유효한 행만 선택
#                 expense_df = df_cleaned[(df_cleaned['구분'] == '지출') & (df_cleaned['현금흐름 항목'].notna())].copy()
# 
#                 if not expense_df.empty:
#                     # 월별, 현금흐름 항목별 지출 합계 계산
#                     monthly_expense_by_item = expense_df.groupby(
#                         [expense_df['회계일'].dt.strftime('%Y-%m'), '현금흐름 항목']
#                     )['대변'].sum().reset_index()
#                     monthly_expense_by_item.columns = ['월', '현금흐름 항목', '총 지출']
# 
#                     # 꺾은선 그래프 생성 (color 인자에 '현금흐름 항목' 지정)
#                     fig_expense_trend = px.line(
#                         monthly_expense_by_item,
#                         x='월',
#                         y='총 지출',
#                         color='현금흐름 항목',
#                         markers=True,
#                         title='월별 항목별 지출'
#                     )
# 
#                     # 툴팁 및 X축 라벨 설정
#                     fig_expense_trend.update_layout(
#                         xaxis_title=None,
#                         yaxis_title="총 지출",
#                         hovermode="x unified",
#                         hoverlabel=dict(
#                             bgcolor="white",
#                             font_size=12,
#                             font_family="Arial"
#                         ),
#                         xaxis=dict(tickangle=0)
#                     )
# 
#                     # 툴팁에 '총 지출' 금액을 원화 단위로 표시
#                     fig_expense_trend.update_traces(
#                         hovertemplate='<b>%{x}</b><br>총 지출: %{y:,.0f} 원<extra></extra>'
#                     )
# 
#                     st.plotly_chart(fig_expense_trend, use_container_width=True)
#                 else:
#                     st.info("지출 데이터가 충분하지 않습니다.")
# 
#             else:
#                 st.info("데이터가 충분하지 않습니다. ('회계일', '잔액', '전표번호', '순번' 컬럼이 필요합니다.)")
# 
#         # 5. 컬럼 3: 파이차트 2개
#         with col3:
#             st.subheader("수입/지출 항목별 비중")
# 
#             # --- 년도와 월 선택기를 한 줄에 배치 ---
#             col3_1, col3_2 = st.columns(2)
# 
#             if '회계일' in df_cleaned.columns and not df_cleaned.empty:
#                 # 유일한 연도와 월 추출
#                 df_cleaned['year'] = df_cleaned['회계일'].dt.year
#                 df_cleaned['month'] = df_cleaned['회계일'].dt.month
# 
#                 # nan이 아닌 유효한 연도만 추출하고 정수형으로 변환
#                 years = sorted([int(y) for y in df_cleaned['year'].unique() if pd.notna(y)])
# 
#                 # 월을 '1월', '2월' 형식으로 변환
#                 months_str = [f"{m}월" for m in range(1, 13)]
# 
#                 if years:
#                     with col3_1:
#                         selected_year = st.selectbox("년도 선택", years, index=len(years)-1, format_func=lambda x: f"{x}년")
#                     with col3_2:
#                         selected_month_str = st.selectbox("월 선택", months_str, index=date.today().month-1)
#                 else:
#                     st.info("데이터에 유효한 연도 정보가 없습니다.")
#                     selected_year = None
#                     selected_month_str = None
# 
#                 selected_month = int(selected_month_str.replace('월', '')) if selected_month_str else None
# 
#                 if selected_year and selected_month:
#                     df_filtered_by_date = df_cleaned[
#                         (df_cleaned['year'] == selected_year) &
#                         (df_cleaned['month'] == selected_month)
#                     ]
#                 else:
#                     df_filtered_by_date = pd.DataFrame()
#             else:
#                 df_filtered_by_date = pd.DataFrame() # 빈 데이터프레임으로 초기화
#                 st.info("날짜를 기준으로 필터링할 데이터가 없습니다.")
# 
#             # 5-1. 수입 파이차트
#             st.markdown("### 수입 항목별 비중")
#             income_df = df_filtered_by_date[df_filtered_by_date['구분'] == '수입']
# 
#             if not income_df.empty:
#                 income_summary = income_df.groupby('현금흐름 항목')['차변'].sum().reset_index()
#                 fig_income = px.pie(
#                     income_summary,
#                     values='차변',
#                     names='현금흐름 항목',
#                     title=f'{selected_year}년 {selected_month}월 수입 항목별 비중'
#                 )
#                 fig_income.update_traces(textposition='inside', textinfo='percent+label')
#                 st.plotly_chart(fig_income, use_container_width=True)
#             else:
#                 st.info("해당 기간의 수입 데이터가 없습니다.")
# 
#             st.markdown("---")
# 
#             # 5-2. 지출 파이차트
#             st.markdown("### 지출 항목별 비중")
#             expense_df = df_filtered_by_date[df_filtered_by_date['구분'] == '지출']
# 
#             if not expense_df.empty:
#                 expense_summary = expense_df.groupby('현금흐름 항목')['대변'].sum().reset_index()
#                 fig_expense = px.pie(
#                     expense_summary,
#                     values='대변',
#                     names='현금흐름 항목',
#                     title=f'{selected_year}년 {selected_month}월 지출 항목별 비중'
#                 )
#                 fig_expense.update_traces(textposition='inside', textinfo='percent+label')
#                 st.plotly_chart(fig_expense, use_container_width=True)
#             else:
#                 st.info("해당 기간의 지출 데이터가 없습니다.")
# 
#         # 수정된 DataFrame을 메모리에 있는 엑셀 파일로 저장
#         output = io.BytesIO()
#         with pd.ExcelWriter(output, engine='openpyxl') as writer:
#             df_cleaned.to_excel(writer, index=False, sheet_name='Sheet1')
# 
#         # 다운로드 버튼 추가
#         st.sidebar.download_button(
#             label="수정된 엑셀 다운로드",
#             data=output.getvalue(),
#             file_name="cleaned_data_with_cash_flow.xlsx",
#             mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
#         )
# 
#         # 처리된 데이터프레임 표시 (선택사항)
#         with st.expander("처리된 데이터 확인"):
#             st.dataframe(df_cleaned)
# 
#     except Exception as e:
#         st.sidebar.error(f"파일을 처리하는 중 오류가 발생했습니다: {e}")
#

import os
from pyngrok import ngrok

# 여기에 발급받은 실제 토큰을 붙여넣으세요.
ngrok_token = "31tQ7vgtLDWYnSCoFpbcEWyYynT_6k9LBhyMBVwBwPojUzpct"
os.environ["NGROK_AUTH_TOKEN"] = ngrok_token
ngrok.set_auth_token(ngrok_token)

public_url = ngrok.connect(8501)
print("Streamlit 앱 주소:", public_url)

!streamlit run app.py &>/dev/null&
